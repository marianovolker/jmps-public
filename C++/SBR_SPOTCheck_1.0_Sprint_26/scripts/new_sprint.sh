#!/bin/sh

#=========================================================================================================
#=========================================================================================================
#=========================================================================================================
#=========================================================================================================
###### Following functions are for spotcheck project only, and need to be adapted for others uses!.
#=========================================================================================================
#=========================================================================================================
#=========================================================================================================
#=========================================================================================================

#=========================================================================================================
quit()
{
	kill $! >/dev/null 2>&1
	reset
	warning "Interrupt signal received, quiting ..."
	exit 0
}
#=========================================================================================================

#=========================================================================================================
setup()
{
	test -z "$next_sprint" && error "ERROR: The argument was not set or need to run check_parameter() function first." && exit 1

	g_major_no=0
	g_minor_no=0
	g_rev_no=0
	g_version_reference_filename="app/spotcheck/Version/version.cpp"

	working_dir="/home/hstools/workspace"
	http_trunk="http://svn.gso.gilbarco.com/repos/spotcheck/trunk/"
	http_branch="http://svn.gso.gilbarco.com/repos/spotcheck/branches/SBR_SPOTCheck_1.0_Sprint_"
	
	trap quit 2
	trap quit 15

	previous_sprint=$((($next_sprint - 1)))
	there_is_previous_sprint=$(( test "$previous_sprint" -gt 0 && printf "y" ) || ( printf "n" ))

	http_previous_branch="$http_branch""$previous_sprint"
	http_next_branch="$http_branch""$next_sprint"
	dir_next_branch=$(basename $http_next_branch)

	return 0
}
#=========================================================================================================

#=========================================================================================================
check_merged_trunk_with_compilation()
{
	local rc=0

	check_working_dir "$working_dir/trunk"
	test $? -ne 0 && error "ERROR: Not in $working_dir/trunk folder..." && return 1

	# These commands are to do the clean, at first, and then does the compilation.
	# Here is where the team need to change the commands for another projects.
	###################################################################################
	ask_for_y_or_n "We're going to build the merged branch and run the units test. [Y/n]?."
	test $? -ne 0 && return 0 

	# Here we are going to build the entire project an run the unit test.
	#---
	./build -c && ./build -c -3 && ./build -c -5 && ./build -c -w && ./build -t
	#---

	# Here we are asking to operator if the entire compilation process was ok.
	ask_for_y_or_n "The compilation was ok. [Y/n]?."

	rc=$?

	# Clean the project to erase files generated by compilation process.
	#---
	./build -c && ./build -c -3 && ./build -c -5 && ./build -c -w
	#---
	###################################################################################

	return $rc
}
#=========================================================================================================

#=========================================================================================================
get_version_of_branch()
{
	check_working_dir "$working_dir/$dir_next_branch"
	test $? -ne 0 && error "ERROR: Not in $working_dir/$dir_next_branch folder..." && return 1
	
	local filename=$g_version_reference_filename
	local pattern="gszVersion"
	local field_1=0
	local field_2=0
	local field_3=0
	local rc=0
	
	field_1=$(cat $filename | grep "$pattern" | sed 's/\"//g' | sed 's/\;//g' | sed 's/\([a-zA-Z]\)//g' | awk -F= '{print $2}' | awk -F. '{printf "%d", $1}')
   rc=$((($rc + $?)))
	field_2=$(cat $filename | grep "$pattern" | sed 's/\"//g' | sed 's/\;//g' | sed 's/\([a-zA-Z]\)//g' | awk -F= '{print $2}' | awk -F. '{printf "%d", $2}')
	rc=$((($rc + $?)))
	field_3=$(cat $filename | grep "$pattern" | sed 's/\"//g' | sed 's/\;//g' | sed 's/\([a-zA-Z]\)//g' | awk -F= '{print $2}' | awk -F. '{printf "%d", $3}')
	rc=$((($rc + $?)))
	test $rc -ne 0 && return 2

	expr $field_1 + 1 2>/dev/null 1>&2
	test $? -ne 0 && return 3
	expr $field_2 + 1 2>/dev/null 1>&2
	test $? -ne 0 && return 4
	expr $field_3 + 1 2>/dev/null 1>&2
	test $? -ne 0 && return 5

#	Get revision number as the proposed sprint number
	field_3="$next_sprint"

#	Counterwise increment if any of the two last fields overflows 99
	test "$field_3" -gt 99 && field_2=$(expr "$field_2" + 1 2>/dev/null)
	test "$field_2" -gt 99 && field_1=$(expr "$field_1" + 1 2>/dev/null)
	test "$field_3" -gt 99 && field_3=0

#	Update fundamental global variables for further use
	g_major_no=$field_1
	g_minor_no=$field_2
	g_rev_no=$field_3

	return $rc
}
#=========================================================================================================

#=========================================================================================================
change_app_version()
{
	local filename=$1
	local pattern="gszVersion"

	sed -i -e "/$pattern/d" -e "/#endif/d" $filename 2>/dev/null
	test $? -ne 0 && return 1

	sed -i -e '$d' $filename 2>/dev/null
	test $? -ne 0 && return 2

	sed -i -e '$d' $filename 2>/dev/null
	test $? -ne 0 && return 3

	printf "char gszVersion[] = \" V%02d.%02d.%02d \";\n" $g_major_no $g_minor_no $g_rev_no 1>> $filename 2>/dev/null
	test $? -ne 0 && return 4

	printf "\n#endif\n\n" 1>> $filename 2>/dev/null
	test $? -ne 0 && return 5

	return 0
}
#=========================================================================================================

#=========================================================================================================
change_installer_version()
{
	local filename="installer/SPOTCheck_windows.iss"
	local rc=0
	local old1="AppVerName=SPOTCheck ..\...\..."
	local old2="OutputBaseFilename=SPOTCheck_installer_.._.._.."
	local new1=`printf "AppVerName=SPOTCheck %02d.%02d.%02d" $g_major_no $g_minor_no $g_rev_no`
	local new2=`printf "OutputBaseFilename=SPOTCheck_installer_%02d_%02d_%02d" $g_major_no $g_minor_no $g_rev_no`

	sed -i "s/$old1/$new1/g" $filename
	sed -i "s/$old2/$new2/g" $filename

	return 0
}
#=========================================================================================================

#=========================================================================================================
change_build_multiplatform_script_version()
{
	local filename="build_SPOTCheck_multiplatform.sh"
	local rc=0
	local old="OUTPUT_BASE_FILENAME=SPOTCheck_installer_.._.._.."
	local new=`printf "OUTPUT_BASE_FILENAME=SPOTCheck_installer_%02d_%02d_%02d" $g_major_no $g_minor_no $g_rev_no`

	sed -i "s/$old/$new/g" $filename

	return 0
}
#=========================================================================================================


#=========================================================================================================
change_version_of_branch()
{
	printf "New Product Version:  char gszVersion[] = \" V%02d.%02d.%02d \";\n" $g_major_no $g_minor_no $g_rev_no

	change_app_version           "app/spotcheck/Version/version.cpp"
	change_app_version           "app/spotdashboard/Version/version.cpp"
	change_installer_version
	change_build_multiplatform_script_version
}
#=========================================================================================================

#=========================================================================================================
prepare_project_source_dir_for_spotcheck()
{
	local rc=0

	check_working_dir "$working_dir"
	test $? -ne 0 && error "ERROR: Not in $working_dir folder..." && return 1

	ask_and_execute "Run this command" "test -h source && rm -rf source"
	rc=$((($rc + $?)))	

	ask_and_execute "Run this command" "( test -d source && rm -rf source ) || ( echo -ne )"
	rc=$((($rc + $?)))
	
	ask_and_execute "Run this command" "ln -s $dir_next_branch source"
	rc=$((($rc + $?)))	
	
	ask_and_execute "Run this command" "cp Project_Files/.project Project_Files/.cproject source/"
	rc=$((($rc + $?)))
	
	get_version_of_branch	

	ask_and_execute_function "Run this function" "change_version_of_branch"
	rc=$((($rc + $?)))

	ask_and_execute "Run this command" "svn commit -m \"Change version according to new current sprint $next_sprint.\""
	rc=$((($rc + $?)))

	return $rc	
}
#=========================================================================================================


#=========================================================================================================
#=========================================================================================================
#=========================================================================================================
#=========================================================================================================
###### Following functions are for generic purpose!.
#=========================================================================================================
#=========================================================================================================
#=========================================================================================================
#=========================================================================================================


#=========================================================================================================
check_parameters()
{
	if test $# -ne 1
	then
		echo "This script need only one parameter. This parameter is the number of the next sprint."
		exit 1
	else
		next_sprint=$( expr $1 + 0 2>/dev/null )
		if test -z "$next_sprint" -o "$?" -ne 0
		then
			echo "The argument must be a number that represent the next sprint!."
			exit 2
		fi
	fi
	
	return 0
}
#=========================================================================================================

#=========================================================================================================
start_progress_indicator()
{
	local time_limit=$( ( test -n "$1" && printf "$1" ) || (printf "60") )

	time_limit=$((($time_limit + 0)))
	time_limit=$(( test "$time_limit" -gt 0 && printf "$time_limit" ) || ( printf "60" ))

	interrupt_progress_bar=1

	local bold=$(tput smso)
	local offbold=$(tput rmso)

	printf " "
	tput cuf 3
	while test "$time_limit" -gt 0 -a "$interrupt_progress_bar" -eq 1
	do
		tput cub 6
		echo -ne ": ${bold}[$time_limit]${offbold}"
		time_limit=$((($time_limit - 1)))
		sleep 1
	done 2>/dev/null &
}
#=========================================================================================================

#=========================================================================================================
stop_progress_indicator()
{
	interrupt_progress_bar=0
	sleep 1
	kill $! >/dev/null 2>&1
}
#=========================================================================================================

#=========================================================================================================
ask_for_y_or_n()
{
	local legend=$( ( test -n "$1" && printf "$1" ) || (printf "Continue [Y/n]?.") )
	local ask=y
	local time_limit=45

	echo
	echo
	tput setf 3
	printf "$legend"
	tput setf 7

	start_progress_indicator $time_limit

	read -s -t $time_limit -n 1 ask
	test -z $ask && ask="y"

	stop_progress_indicator

	echo

	test "$ask" = "y" -o "$ask" = "Y" && return 0
	return 1
}
#=========================================================================================================

#=========================================================================================================
ask_and_execute()
{
   local rc=0
   local legend="$1"
   local command="$2"
	local output=""

   if test -n "$command" -a -n "$legend"
   then
      ask_for_y_or_n "$legend [$command]. [Y/n]?: "
      if test $? -eq 0
      then
			output=$(sh -c "$command 2>&1")
         rc=$((($rc + $?)))   
			if test "$rc" -ne 0
			then
				log "[output=[$output]]"
			fi
      fi
   fi
   return $rc
}
#=========================================================================================================

#=========================================================================================================
ask_and_execute_function()
{
   local rc=0
   local legend="$1"
   local function="$2"
   local output=""

   if test -n "$function" -a -n "$legend"
   then
      ask_for_y_or_n "$legend [$function]. [Y/n]?: "
      if test $? -eq 0
      then
         $function
         rc=$((($rc + $?)))   
      fi
   fi
   return $rc
}
#=========================================================================================================

#=========================================================================================================
log()
{
	local line_to_log="$1"
   
	local prefix_to_log=$(date "+%Y.%m.%d_%H:%M:%S:%N:")

	echo

	echo "$prefix_to_log"" [$line_to_log]" 2>/dev/null

	return $?
}
#=========================================================================================================

#=========================================================================================================
warning()
{
	local line_to_log="$1"
   
	local prefix_to_log=$(date "+%Y.%m.%d_%H:%M:%S:%N:")

	echo

	tput setf 6
	echo "$prefix_to_log"" [$line_to_log]" 2>/dev/null
	tput setf 7

	return $?
}
#=========================================================================================================

#=========================================================================================================
error()
{
	local line_to_log="$1"
   
	local prefix_to_log=$(date "+%Y.%m.%d_%H:%M:%S:%N:")

	echo

	tput setf 4
	echo "$prefix_to_log"" [$line_to_log]" 2>/dev/null
	tput setf 7

	return $?
}
#=========================================================================================================

#=========================================================================================================
success()
{
   local line_to_log="$1"
   
   local prefix_to_log=$(date "+%Y.%m.%d_%H:%M:%S:%N:")

   echo

   tput setf 2
   echo "$prefix_to_log"" [$line_to_log]" 2>/dev/null
   tput setf 7

   return $?
}
#=========================================================================================================

#=========================================================================================================
check_working_dir()
{
	local current_dir=$(pwd)
	local local_working_dir=$( ( test -n "$1" && printf "$1" ) || (printf "$working_dir") )
	local rc=0
	
	if test "$current_dir" != "$local_working_dir"
	then
		if test -d "$local_working_dir"
		then
			cd "$local_working_dir"
		else
			rc=1
		fi
	fi

	rc=$((($rc + $?)))
	
	return $rc
}
#=========================================================================================================

#=========================================================================================================
prepare_trunk_folder_to_do_the_merge()
{
	ask_for_y_or_n "Do you want to prepare trunk folder to do the merge?. [Y/n]?."
	test $? -ne 0 && return 0

	check_working_dir "$working_dir"
	test $? -ne 0 && error "ERROR: Not in $working_dir folder..." && return 1

	if ! test -d trunk
	then
		log "svn co $http_trunk trunk"
		svn co $http_trunk trunk
		test $? -eq 0 || ( error "ERROR: Could not create directory trunk." && return 1 )
	
		log "cd trunk"
		cd trunk
	else
		log "cd trunk"
		cd trunk
		
		log "svn update"
		svn update
	fi
	
	return $?
}
#=========================================================================================================

#=========================================================================================================
svn_log()
{
	check_working_dir "$working_dir/trunk"
	test $? -ne 0 && error "ERROR: Not in $working_dir/trunk folder..." && return 1

	ask_for_y_or_n "Run this command [svn log --stop-on-copy -v | less]?. [Y/n]?."
	test $? -eq 0 && svn log --stop-on-copy -v | less

	return $?
}
#=========================================================================================================

#=========================================================================================================
do_the_merge()
{
	if test "$there_is_previous_sprint" == "y"
	then

		check_working_dir "$working_dir/trunk"
		test $? -ne 0 && error "ERROR: Not in $working_dir/trunk folder..." && return 1

		ask_for_y_or_n "Simulate merging to trunk. [svn merge --dry-run $http_previous_branch .]. [Y/n]?."
		test $? -eq 0 && svn merge --dry-run $http_previous_branch . && ask_for_y_or_n "The list of merges showed below is correct?. [Y/n]?."
		
		ask_for_y_or_n "Do you want to merge to trunk. [svn merge $http_previous_branch .]. [Y/n]?."
		test $? -eq 0 && svn merge $http_previous_branch .
		
		check_merged_trunk_with_compilation

		ask_for_y_or_n "We're going to commit at trunk. [svn commit -m \"Merge from $http_previous_branch\"]. [Y/n]?."
		test $? -eq 0 && svn commit -m "Merge from $http_previous_branch"

	fi
	
	return 0
}
#=========================================================================================================

#=========================================================================================================
create_branch_for_next_sprint()
{
	ask_for_y_or_n "We're going to create new branch for the next sprint. [svn copy -m \"Branch for sprint $next_sprint.\" $http_trunk $http_next_branch]. [Y/n]?."
	test $? -eq 0 && svn copy -m "Branch for sprint $next_sprint." $http_trunk $http_next_branch
	
	return 0
}
#=========================================================================================================

#=========================================================================================================
check_out_next_sprint_branch()
{
	check_working_dir "$working_dir"
	test $? -ne 0 && error "ERROR: Not in $working_dir folder..." && return 1

	test -d $dir_next_branch && warning "WARNING!. This folder [$dir_next_branch] exist!." && return 0

	ask_for_y_or_n "Run this command [svn co $http_next_branch]. [Y/n]?."
	test $? -eq 0 && svn co $http_next_branch
	
	return 0
}
#=========================================================================================================

#=========================================================================================================
main()
{
	###################################################################################
	check_parameters "$*"
	
	setup

	prepare_trunk_folder_to_do_the_merge
	test $? -ne 0 && error "ERROR in prepare_trunk_folder_to_do_the_merge(). Quiting ..." && exit 1
	
	svn_log

	do_the_merge
	test $? -ne 0 && error "ERROR in do_the_merge(). Quiting ..." && exit 2
	
	create_branch_for_next_sprint
	test $? -ne 0 && error "ERROR in create_branch_for_next_sprint(). Quiting ..." && exit 3

	check_out_next_sprint_branch
	test $? -ne 0 && error "ERROR in check_out_next_sprint_branch(). Quiting ..." && exit 4

	prepare_project_source_dir_for_spotcheck
	test $? -ne 0 && error "ERROR in prepare_project_source_dir_for_spotcheck(). Quiting ..." && exit 5

	success "SUCCESS!."
	###################################################################################

	return 0
}
#=========================================================================================================

#=========================================================================================================
main $*
exit 0
#=========================================================================================================
